// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod daylight {

  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};
#[allow(unused_imports, dead_code)]
pub mod common {

  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_LANGUAGE: u16 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_LANGUAGE: u16 = 3;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_LANGUAGE: [Language; 4] = [
  Language::Unspecified,
  Language::Agda,
  Language::Bash,
  Language::C,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct Language(pub u16);
#[allow(non_upper_case_globals)]
impl Language {
  pub const Unspecified: Self = Self(0);
  pub const Agda: Self = Self(1);
  pub const Bash: Self = Self(2);
  pub const C: Self = Self(3);

  pub const ENUM_MIN: u16 = 0;
  pub const ENUM_MAX: u16 = 3;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::Unspecified,
    Self::Agda,
    Self::Bash,
    Self::C,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::Unspecified => Some("Unspecified"),
      Self::Agda => Some("Agda"),
      Self::Bash => Some("Bash"),
      Self::C => Some("C"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for Language {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for Language {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = unsafe { flatbuffers::read_scalar_at::<u16>(buf, loc) };
    Self(b)
  }
}

impl flatbuffers::Push for Language {
    type Output = Language;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe { flatbuffers::emplace_scalar::<u16>(dst, self.0); }
    }
}

impl flatbuffers::EndianScalar for Language {
  type Scalar = u16;
  #[inline]
  fn to_little_endian(self) -> u16 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u16) -> Self {
    let b = u16::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for Language {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u16::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Language {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_ERROR_CODE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_ERROR_CODE: i8 = 3;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ERROR_CODE: [ErrorCode; 4] = [
  ErrorCode::Unspecified,
  ErrorCode::TimedOut,
  ErrorCode::Cancelled,
  ErrorCode::UnknownLanguage,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct ErrorCode(pub i8);
#[allow(non_upper_case_globals)]
impl ErrorCode {
  pub const Unspecified: Self = Self(0);
  pub const TimedOut: Self = Self(1);
  pub const Cancelled: Self = Self(2);
  pub const UnknownLanguage: Self = Self(3);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 3;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::Unspecified,
    Self::TimedOut,
    Self::Cancelled,
    Self::UnknownLanguage,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::Unspecified => Some("Unspecified"),
      Self::TimedOut => Some("TimedOut"),
      Self::Cancelled => Some("Cancelled"),
      Self::UnknownLanguage => Some("UnknownLanguage"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for ErrorCode {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for ErrorCode {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = unsafe { flatbuffers::read_scalar_at::<i8>(buf, loc) };
    Self(b)
  }
}

impl flatbuffers::Push for ErrorCode {
    type Output = ErrorCode;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe { flatbuffers::emplace_scalar::<i8>(dst, self.0); }
    }
}

impl flatbuffers::EndianScalar for ErrorCode {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for ErrorCode {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for ErrorCode {}
}  // pub mod common

#[allow(unused_imports, dead_code)]
pub mod html {

  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};

pub enum FileOffset {}
#[derive(Copy, Clone, PartialEq)]

/// A file to be highlighted.
pub struct File<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for File<'a> {
  type Inner = File<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> File<'a> {
  pub const VT_IDENT: flatbuffers::VOffsetT = 4;
  pub const VT_FILENAME: flatbuffers::VOffsetT = 6;
  pub const VT_CONTENTS: flatbuffers::VOffsetT = 8;
  pub const VT_LANGUAGE: flatbuffers::VOffsetT = 10;
  pub const VT_OPTIONS: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    File { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args FileArgs<'args>
  ) -> flatbuffers::WIPOffset<File<'bldr>> {
    let mut builder = FileBuilder::new(_fbb);
    if let Some(x) = args.options { builder.add_options(x); }
    if let Some(x) = args.contents { builder.add_contents(x); }
    if let Some(x) = args.filename { builder.add_filename(x); }
    builder.add_language(args.language);
    builder.add_ident(args.ident);
    builder.finish()
  }


  /// A unique numeric identifier used to correlate files in a request with files in a response.
  /// Often this will be an array index. If two files are passed with the same ident, the behavior
  /// is undefined. Invariant: for each file in a request, there will be either a Document or a Failure
  /// with that ident.
  #[inline]
  pub fn ident(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(File::VT_IDENT, Some(0)).unwrap()}
  }
  /// An optional filename for this file.
  #[inline]
  pub fn filename(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(File::VT_FILENAME, None)}
  }
  /// The contents of this file.
  #[inline]
  pub fn contents(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(File::VT_CONTENTS, None)}
  }
  /// The language for this to use. If this is unspecified, the server will make an attempt to
  /// infer the language based on its filename. If that is unsuccessful, the file is considered
  /// bad and a Failure will be returned.
  #[inline]
  pub fn language(&self) -> super::common::Language {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<super::common::Language>(File::VT_LANGUAGE, Some(super::common::Language::Unspecified)).unwrap()}
  }
  /// Not currently used.
  #[inline]
  pub fn options(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(File::VT_OPTIONS, None)}
  }
}

impl flatbuffers::Verifiable for File<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u16>("ident", Self::VT_IDENT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("filename", Self::VT_FILENAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("contents", Self::VT_CONTENTS, false)?
     .visit_field::<super::common::Language>("language", Self::VT_LANGUAGE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("options", Self::VT_OPTIONS, false)?
     .finish();
    Ok(())
  }
}
pub struct FileArgs<'a> {
    pub ident: u16,
    pub filename: Option<flatbuffers::WIPOffset<&'a str>>,
    pub contents: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub language: super::common::Language,
    pub options: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
}
impl<'a> Default for FileArgs<'a> {
  #[inline]
  fn default() -> Self {
    FileArgs {
      ident: 0,
      filename: None,
      contents: None,
      language: super::common::Language::Unspecified,
      options: None,
    }
  }
}

pub struct FileBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> FileBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_ident(&mut self, ident: u16) {
    self.fbb_.push_slot::<u16>(File::VT_IDENT, ident, 0);
  }
  #[inline]
  pub fn add_filename(&mut self, filename: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(File::VT_FILENAME, filename);
  }
  #[inline]
  pub fn add_contents(&mut self, contents: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(File::VT_CONTENTS, contents);
  }
  #[inline]
  pub fn add_language(&mut self, language: super::common::Language) {
    self.fbb_.push_slot::<super::common::Language>(File::VT_LANGUAGE, language, super::common::Language::Unspecified);
  }
  #[inline]
  pub fn add_options(&mut self, options: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(File::VT_OPTIONS, options);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> FileBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    FileBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<File<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for File<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("File");
      ds.field("ident", &self.ident());
      ds.field("filename", &self.filename());
      ds.field("contents", &self.contents());
      ds.field("language", &self.language());
      ds.field("options", &self.options());
      ds.finish()
  }
}
pub enum RequestOffset {}
#[derive(Copy, Clone, PartialEq)]

/// A request to highlight some files as HTML.
pub struct Request<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Request<'a> {
  type Inner = Request<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> Request<'a> {
  pub const VT_FILES: flatbuffers::VOffsetT = 4;
  pub const VT_TIMEOUT_MS: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Request { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args RequestArgs<'args>
  ) -> flatbuffers::WIPOffset<Request<'bldr>> {
    let mut builder = RequestBuilder::new(_fbb);
    builder.add_timeout_ms(args.timeout_ms);
    if let Some(x) = args.files { builder.add_files(x); }
    builder.finish()
  }


  #[inline]
  pub fn files(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<File<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<File>>>>(Request::VT_FILES, None)}
  }
  /// The maximum time a file is allowed to take. If zero or not provided, the server may choose a timeout.
  /// Passing a size larger than the server's supported per-file timeout produces a `400 Bad Request`.
  #[inline]
  pub fn timeout_ms(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(Request::VT_TIMEOUT_MS, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for Request<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<File>>>>("files", Self::VT_FILES, false)?
     .visit_field::<u64>("timeout_ms", Self::VT_TIMEOUT_MS, false)?
     .finish();
    Ok(())
  }
}
pub struct RequestArgs<'a> {
    pub files: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<File<'a>>>>>,
    pub timeout_ms: u64,
}
impl<'a> Default for RequestArgs<'a> {
  #[inline]
  fn default() -> Self {
    RequestArgs {
      files: None,
      timeout_ms: 0,
    }
  }
}

pub struct RequestBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> RequestBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_files(&mut self, files: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<File<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Request::VT_FILES, files);
  }
  #[inline]
  pub fn add_timeout_ms(&mut self, timeout_ms: u64) {
    self.fbb_.push_slot::<u64>(Request::VT_TIMEOUT_MS, timeout_ms, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> RequestBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    RequestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Request<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Request<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Request");
      ds.field("files", &self.files());
      ds.field("timeout_ms", &self.timeout_ms());
      ds.finish()
  }
}
pub enum ResponseOffset {}
#[derive(Copy, Clone, PartialEq)]

/// A response containing either highlighted documents or failures.
/// Both documents and failures can appear in any order, regardless of how they were ordered in the request.
/// Use their .ident properties to build a mapping between request and response.
/// Invariant: len(documents) + len(failures) = len(request.files) iff no idents are duplicated.
pub struct Response<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Response<'a> {
  type Inner = Response<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> Response<'a> {
  pub const VT_DOCUMENTS: flatbuffers::VOffsetT = 4;
  pub const VT_FAILURES: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Response { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ResponseArgs<'args>
  ) -> flatbuffers::WIPOffset<Response<'bldr>> {
    let mut builder = ResponseBuilder::new(_fbb);
    if let Some(x) = args.failures { builder.add_failures(x); }
    if let Some(x) = args.documents { builder.add_documents(x); }
    builder.finish()
  }


  #[inline]
  pub fn documents(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Document<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Document>>>>(Response::VT_DOCUMENTS, None)}
  }
  #[inline]
  pub fn failures(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Failure<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Failure>>>>(Response::VT_FAILURES, None)}
  }
}

impl flatbuffers::Verifiable for Response<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Document>>>>("documents", Self::VT_DOCUMENTS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Failure>>>>("failures", Self::VT_FAILURES, false)?
     .finish();
    Ok(())
  }
}
pub struct ResponseArgs<'a> {
    pub documents: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Document<'a>>>>>,
    pub failures: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Failure<'a>>>>>,
}
impl<'a> Default for ResponseArgs<'a> {
  #[inline]
  fn default() -> Self {
    ResponseArgs {
      documents: None,
      failures: None,
    }
  }
}

pub struct ResponseBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ResponseBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_documents(&mut self, documents: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Document<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Response::VT_DOCUMENTS, documents);
  }
  #[inline]
  pub fn add_failures(&mut self, failures: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Failure<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Response::VT_FAILURES, failures);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ResponseBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ResponseBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Response<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Response<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Response");
      ds.field("documents", &self.documents());
      ds.field("failures", &self.failures());
      ds.finish()
  }
}
pub enum DocumentOffset {}
#[derive(Copy, Clone, PartialEq)]

/// A successfully highlighted document.
pub struct Document<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Document<'a> {
  type Inner = Document<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> Document<'a> {
  pub const VT_IDENT: flatbuffers::VOffsetT = 4;
  pub const VT_FILENAME: flatbuffers::VOffsetT = 6;
  pub const VT_LANGUAGE: flatbuffers::VOffsetT = 8;
  pub const VT_LINES: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Document { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DocumentArgs<'args>
  ) -> flatbuffers::WIPOffset<Document<'bldr>> {
    let mut builder = DocumentBuilder::new(_fbb);
    if let Some(x) = args.lines { builder.add_lines(x); }
    if let Some(x) = args.filename { builder.add_filename(x); }
    builder.add_language(args.language);
    builder.add_ident(args.ident);
    builder.finish()
  }


  /// The ident corresponding to the File that produced this highlighted document.
  #[inline]
  pub fn ident(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(Document::VT_IDENT, Some(0)).unwrap()}
  }
  /// The file name, provided as a convenience.
  #[inline]
  pub fn filename(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Document::VT_FILENAME, None)}
  }
  /// The language that was used or inferred for this file.
  #[inline]
  pub fn language(&self) -> super::common::Language {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<super::common::Language>(Document::VT_LANGUAGE, Some(super::common::Language::Unspecified)).unwrap()}
  }
  /// Lines of HTML.
  #[inline]
  pub fn lines(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(Document::VT_LINES, None)}
  }
}

impl flatbuffers::Verifiable for Document<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u16>("ident", Self::VT_IDENT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("filename", Self::VT_FILENAME, false)?
     .visit_field::<super::common::Language>("language", Self::VT_LANGUAGE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("lines", Self::VT_LINES, false)?
     .finish();
    Ok(())
  }
}
pub struct DocumentArgs<'a> {
    pub ident: u16,
    pub filename: Option<flatbuffers::WIPOffset<&'a str>>,
    pub language: super::common::Language,
    pub lines: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
}
impl<'a> Default for DocumentArgs<'a> {
  #[inline]
  fn default() -> Self {
    DocumentArgs {
      ident: 0,
      filename: None,
      language: super::common::Language::Unspecified,
      lines: None,
    }
  }
}

pub struct DocumentBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DocumentBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_ident(&mut self, ident: u16) {
    self.fbb_.push_slot::<u16>(Document::VT_IDENT, ident, 0);
  }
  #[inline]
  pub fn add_filename(&mut self, filename: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Document::VT_FILENAME, filename);
  }
  #[inline]
  pub fn add_language(&mut self, language: super::common::Language) {
    self.fbb_.push_slot::<super::common::Language>(Document::VT_LANGUAGE, language, super::common::Language::Unspecified);
  }
  #[inline]
  pub fn add_lines(&mut self, lines: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Document::VT_LINES, lines);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DocumentBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DocumentBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Document<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Document<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Document");
      ds.field("ident", &self.ident());
      ds.field("filename", &self.filename());
      ds.field("language", &self.language());
      ds.field("lines", &self.lines());
      ds.finish()
  }
}
pub enum FailureOffset {}
#[derive(Copy, Clone, PartialEq)]

/// A document that failed to highlight.
pub struct Failure<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Failure<'a> {
  type Inner = Failure<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> Failure<'a> {
  pub const VT_IDENT: flatbuffers::VOffsetT = 4;
  pub const VT_REASON: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Failure { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args FailureArgs
  ) -> flatbuffers::WIPOffset<Failure<'bldr>> {
    let mut builder = FailureBuilder::new(_fbb);
    builder.add_ident(args.ident);
    builder.add_reason(args.reason);
    builder.finish()
  }


  /// The ident corresponding to the File that produced this highlighted failure.
  #[inline]
  pub fn ident(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(Failure::VT_IDENT, Some(0)).unwrap()}
  }
  /// An error code describing the nature of this failure.
  #[inline]
  pub fn reason(&self) -> super::common::ErrorCode {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<super::common::ErrorCode>(Failure::VT_REASON, Some(super::common::ErrorCode::Unspecified)).unwrap()}
  }
}

impl flatbuffers::Verifiable for Failure<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u16>("ident", Self::VT_IDENT, false)?
     .visit_field::<super::common::ErrorCode>("reason", Self::VT_REASON, false)?
     .finish();
    Ok(())
  }
}
pub struct FailureArgs {
    pub ident: u16,
    pub reason: super::common::ErrorCode,
}
impl<'a> Default for FailureArgs {
  #[inline]
  fn default() -> Self {
    FailureArgs {
      ident: 0,
      reason: super::common::ErrorCode::Unspecified,
    }
  }
}

pub struct FailureBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> FailureBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_ident(&mut self, ident: u16) {
    self.fbb_.push_slot::<u16>(Failure::VT_IDENT, ident, 0);
  }
  #[inline]
  pub fn add_reason(&mut self, reason: super::common::ErrorCode) {
    self.fbb_.push_slot::<super::common::ErrorCode>(Failure::VT_REASON, reason, super::common::ErrorCode::Unspecified);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> FailureBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    FailureBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Failure<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Failure<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Failure");
      ds.field("ident", &self.ident());
      ds.field("reason", &self.reason());
      ds.finish()
  }
}
}  // pub mod html
}  // pub mod daylight

